# SmartPlanner: сравнение императивного и декларативного подходов

Проект SmartPlanner реализован в двух вариантах:

- iOS приложение на **UIKit** с программной версткой экранов
- Android приложение на **Jetpack Compose**

## Императивный подход (UIKit)

В iOS версии используются:

- `UIViewController`, `UITableView`, кастомная `UITableViewCell`
- ручная настройка и обновление UI через свойства и методы
- делегаты и протоколы для передачи данных между экранами

Характерные моменты:

- нужно явно настраивать иерархию вью, констрейнты, перезагрузку таблицы
- состояние задач хранится в массиве в контроллере, разработчик сам решает, когда вызвать `reloadData()`
- навигация между экранами организуется вручную через `UINavigationController`

### Плюсы

- полный контроль над жизненным циклом и вью
- понятная модель для тех, кто давно работает с UIKit
- легко реализовывать нетипичные сценарии и сложные кастомные переходы

### Трудности

- много шаблонного кода для настройки интерфейса
- легко забыть обновить UI после изменения данных
- при росте экрана контроллер быстро разрастается и становится сложным для поддержки

---

## Декларативный подход (Jetpack Compose)

В Android версии используются:

- `@Composable` функции вместо классов контроллеров
- состояние в виде `remember { mutableStateOf(...) }`
- отображение списка через `LazyColumn` и функций `TaskItem`, `CreateTaskScreen` и других

Характерные моменты:

- UI описывается как функция от состояния
- при изменении списка задач или параметров сортировки Compose сам перерасчитывает и перерисовывает нужные части
- навигация внутри вкладки задач реализована через простое условие `if (isCreatingTask) { ... } else { ... }`, без ручного управления экранами

### Плюсы

- меньше кода для описания интерфейса и состояний
- проще рассуждать о том, как выглядит экран при конкретном состоянии данных
- сортировка, фильтрация и изменение задач отражаются в UI автоматически при изменении стейта

### Трудности

- требуется привыкнуть к мысли, что UI пересоздается при изменении состояния
- сложнее отлаживать, если перепутать, где хранится состояние и кто за него отвечает
- важно аккуратно выбирать, где хранить состояние, чтобы не возникало лишних перерисовок

---

## Основные отличия в контексте задачи

1. **Список задач и сортировка**

   - UIKit  
     Состояние списка задач хранится в контроллере. После изменения массива разработчик сам вызывает `tableView.reloadData()`.  
     Сортировка по приоритету или дате выполняется вручную через `sorted`, результат нужно снова сохранить и обновить таблицу.

   - Compose  
     Список задач хранится в `remember { mutableStateOf(listOf<Task>()) }`. При изменении массива или режима сортировки достаточно поменять значение стейта. UI автоматически пересобирает `LazyColumn` на основе нового списка.

2. **Экран создания задачи**

   - UIKit  
     Используются `UITextField`, `UITextView`, `UISwitch` и другие элементы. Передача новой задачи назад происходит через делегат. Верстка и констрейнты настраиваются вручную, также вручную проверяются обязательные поля.

   - Compose  
     Для полей используются `OutlinedTextField`, `Switch`, `Button`, `FilterChip`. Все значения полей хранятся в локальном состоянии функции. При нажатии на кнопку сохранить создается объект `Task` и передается наружу через лямбда параметр `onSave`.

3. **Маркировка приоритета и флага**

   - UIKit  
     Цветная плашка приоритета реализована внутри ячейки, через настройки слоев и констрейнтов. При изменении приоритета нужно обновить соответствующие свойства вью.

   - Compose  
     Плашка приоритета описана как комбинация `Box` и модификаторов `background`, `width`, `height`. Цвет берется напрямую из `task.priority`, без явного обращения к вью слоям.

---

## Что лучше подходит для каких задач

- **Императивный подход (UIKit)** удобнее:
  - когда нужно тонко и детально управлять вью и анимациями
  - если проект уже целиком на UIKit и важно следовать текущей архитектуре
  - для задач, где жизненный цикл вью и контроллеров важен и уже хорошо знаком

- **Декларативный подход (Compose)** удобнее:
  - когда много экранов со списками и состояниями, которые часто меняются
  - когда логика экрана напрямую связана с состоянием данных, и важно, чтобы UI просто следовал за этим состоянием
  - для быстрого прототипирования и разработки новых экранов

---

## Личный вывод

В рамках этого задания:

- экран списка задач и экран создания задачи ощущаются более естественными в декларативном подходе, так как они напрямую завязаны на состояние списка, фильтры и сортировку
- в UIKit реализация получилась немного более многословной за счет ручного обновления таблиц и верстки, но при этом дает хороший контроль над стадиями жизни экрана
- для дальнейшего развития такого планировщика я бы предпочла декларативный подход для части, связанной с отображением списков и форм, и императивный там, где требуется сложное управление навигацией и специфическими сценариями



